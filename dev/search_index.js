var documenterSearchIndex = {"docs":
[{"title":"GeometryExperiments","page":"Home","location":"#GeometryExperiments","category":"section","text":""},{"title":"Home","page":"Home","location":"","category":"page","text":"Documentation for GeometryExperiments."},{"title":"Home","page":"Home","location":"","category":"page","text":"(work in progress)"},{"title":"Home","page":"Home","location":"","category":"page","text":""},{"title":"GeometryExperiments.BezierCurve","page":"Home","location":"#GeometryExperiments.BezierCurve-Tuple{Any}","category":"method","text":"Apply Horner's method on the monomial representation of the Bézier curve B = ∑ᵢ aᵢtⁱ with i ∈ [0, n], n the degree of the curve, aᵢ = binomial(n, i) * pᵢ * t̄ⁿ⁻ⁱ and t̄ = (1 - t). Horner's rule recursively reconstructs B from a sequence bᵢ with bₙ = aₙ and bᵢ₋₁ = aᵢ₋₁ + bᵢ * t until b₀ = B.\n\n\n\n\n\n"},{"title":"GeometryExperiments.BezierEvalMethod","page":"Home","location":"#GeometryExperiments.BezierEvalMethod","category":"type","text":"Evaluation method used to obtain a point along a Bézier curve from a parametric expression.\n\n\n\n\n\n"},{"title":"GeometryExperiments.EdgeIterator","page":"Home","location":"#GeometryExperiments.EdgeIterator","category":"type","text":"Iterator on a mesh face which returns a tuple (prev, next, edge, swapped) where prev and next are the previous and next vertices in the edge cycle, edge the corresponding undirected edge and swapped a boolean value indicating whether the vertices of the undirected edge were swapped to yield prev and next.\n\nThe face must be a complete cycle of connected edges. Edges are not required to be connected exactly at dst => src points; since they are undirected, the last next vertex must simply be included as one of the two endpoints of the next edge in the face.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Ellipsoid","page":"Home","location":"#GeometryExperiments.Ellipsoid","category":"type","text":"Ellipsoid(semiaxes)\n\nAn ellipsoid with semi-axes semiaxes. Is equivalent to a scaled HyperSphere.\n\n\n\n\n\n"},{"title":"GeometryExperiments.FixedDegree","page":"Home","location":"#GeometryExperiments.FixedDegree","category":"type","text":"Fast evaluation in the case of a fixed small number N of control points.\n\n\n\n\n\n"},{"title":"GeometryExperiments.GranularVector","page":"Home","location":"#GeometryExperiments.GranularVector","category":"type","text":"A vector type which can have items deleted without modifying indices of other values.\n\nFeatures include:\n\nNo hashing is ever performed to access its contents.\nThe underlying buffer is contiguous in memory.\nNo allocations occur when retrieving elements by indices from that container or when iterating on the whole container.\nElements can be deleted from the container without having to worry about indices of other elements being shifted.\n\nIt is furthermore optimized to reuse indices of previously deleted elements when the number of deleted elements is greater than the number of live elements in the collection. For this reason, push! is O(n/2) in the worst case scenario (which should very rarely happen).\n\nNote that buffer slots are never deleted by purpose, except with empty!. Therefore, if the container grows then shrinks logically, memory won't be freed automatically. In this case, you must empty! the container manually or build another one.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Horner","page":"Home","location":"#GeometryExperiments.Horner","category":"type","text":"Approximate evaluation using Horner's method. Recommended for a large number of control points, if you can afford a precision loss. See https://en.wikipedia.org/wiki/Horner%27s_method.\n\n\n\n\n\n"},{"title":"GeometryExperiments.HyperSphere","page":"Home","location":"#GeometryExperiments.HyperSphere","category":"type","text":"Hypersphere centered around the origin\n\n\n\n\n\n"},{"title":"GeometryExperiments.Mesh","page":"Home","location":"#GeometryExperiments.Mesh","category":"type","text":"General representation of a two-dimensional mesh embedded in an arbitrary space.\n\nThe associated surface needs not be manifold; there can be dangling edges, lone vertices, and faces linked only by a single vertex.\n\n\n\n\n\n"},{"title":"GeometryExperiments.MeshEncoding","page":"Home","location":"#GeometryExperiments.MeshEncoding","category":"type","text":"Way to connect the various elements of a mesh, encoding its connectivity using integer indices.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Patch","page":"Home","location":"#GeometryExperiments.Patch","category":"type","text":"Patch made by \"gluing\" curves together.\n\nIf compact is set to true, each curve starts from the point of the last curve, assumed to be on the curve.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Projection","page":"Home","location":"#GeometryExperiments.Projection","category":"type","text":"Projection of an object of type O onto the first N dimensions.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Quaternion","page":"Home","location":"#GeometryExperiments.Quaternion","category":"type","text":"Quaternion, using an WXYZ convention (real part first, then pure part).\n\n\n\n\n\n"},{"title":"GeometryExperiments.SmoothingStrategy","page":"Home","location":"#GeometryExperiments.SmoothingStrategy","category":"type","text":"Describe how vertex normals should be computed for a given mesh.\n\n\n\n\n\n"},{"title":"GeometryExperiments.Transform","page":"Home","location":"#GeometryExperiments.Transform","category":"type","text":"Linear transformation in Euclidean space.\n\nA Transform encodes a linear operation obtained by scaling, rotating and translating an object, in this particular order. Scaling and rotation are defined around the origin; rotation around another object must be encoded as a rotation first and then a translation.\n\nTo apply the transform to a point, use apply_transform(p, transform) To apply the inverse of this transform to a point, use apply_transform_inverse(p, transform).\n\n\n\n\n\n"},{"title":"GeometryExperiments.VertexMesh","page":"Home","location":"#GeometryExperiments.VertexMesh","category":"type","text":"Mesh represented with indexed vertices using a specific MeshEncoding.\n\n\n\n\n\n"},{"title":"Base.allunique","page":"Home","location":"#Base.allunique-Tuple{Mesh}","category":"method","text":"Check whether the mesh has duplicate elements.\n\n\n\n\n\n"},{"title":"GeometryExperiments.angle","page":"Home","location":"#GeometryExperiments.angle-Tuple{StaticArraysCore.SVector, StaticArraysCore.SVector}","category":"method","text":"Angle between (O,x) and (O, y) with O the origin of the Euclidean space.\n\n\n\n\n\n"},{"title":"GeometryExperiments.compute_vertex_normals","page":"Home","location":"#GeometryExperiments.compute_vertex_normals","category":"function","text":"Compute vertex normals for a triangle mesh.\n\n\n\n\n\n"},{"title":"GeometryExperiments.ensure_cyclic_edges!","page":"Home","location":"#GeometryExperiments.ensure_cyclic_edges!-Tuple{MeshFace, Mesh}","category":"method","text":"Make sure that edges specified in the face form a cycle.\n\nIf they don't form a cycle originally, then edges will be reordered so that a cycle can be formed with all edges; otherwise, an error will be thrown.\n\n\n\n\n\n"},{"title":"GeometryExperiments.ismanifold","page":"Home","location":"#GeometryExperiments.ismanifold-Tuple{Mesh}","category":"method","text":"Return whether the mesh represents the boundary of a 3-dimensional volume, i.e. it is homogeneously made of connected faces and there is no boundary (every edge is attached to exactly two faces).\n\n\n\n\n\n"},{"title":"GeometryExperiments.projection","page":"Home","location":"#GeometryExperiments.projection-Tuple{Any, Any}","category":"method","text":"projection(object, x) -> x′\n\nProject x onto object, and return the resulting point x′.\n\n\n\n\n\n"},{"title":"GeometryExperiments.projection_parameter","page":"Home","location":"#GeometryExperiments.projection_parameter","category":"function","text":"projection_parameter(parametric, x) -> t\n\nProject x onto parametric, and return the corresponding value t in parametric's parameter space.\n\n\n\n\n\n"}]
}
